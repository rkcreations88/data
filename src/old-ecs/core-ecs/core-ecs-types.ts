// Â© 2026 Adobe. MIT License. See /LICENSE for details.

import { Data } from "../../index.js";
import { Schema } from "../../schema/index.js";
import { DeepReadonly, Simplify } from "../../types/types.js";
import { NativeArray } from "../../cache/managed-array.js";

/**
 * An Entity represents a single object within the ECS.
 * It is a unique positive integer identifier that can be used to access the components of the entity.
 */
export type Entity = number;
/**
 * Represents all of an entities values for the given ECS components.
 * This will always contain an id property which is the entity id.
 * All other components are optional.
 */
export type EntityValues<C> = { id: number } & {
  [K in keyof C]?: C[K] | undefined;
};
/**
 * Represents the values you can use when creating an entity.
 * You cannot provide an id as this is always generated by the ECS.
 */
export type EntityCreateValues<A> = Omit<A, "id">;
/**
 * Represents the values you can use when updating an entity.
 * Providing a value of undefined for a component will delete it.
 */
export type EntityUpdateValues<C> = Omit<
  { [K in keyof C]?: C[K] | undefined },
  "id"
>;
/**
 * The JSON data type that is used to serialize and deserialize ECS data.
 */
export type ECSJSON = {
  ecs: true;
  version: number;
  components: Record<string, Schema>;
  entities: readonly number[];
  tables: { rows: number; columns: Record<string, Data> }[];
};

export type CoreComponents = { id: number };
export type CoreResources = { [K: string]: Data };

export interface CoreECS<
  C extends CoreComponents = CoreComponents,
  R extends CoreResources = {},
> extends CoreECSRead<C, R>,
  CoreECSWrite<C, R> {
  /**
   * Creates new components within this ecs and returns the same ecs with the new expanded type information.
   */
  withComponents<
    S extends { readonly [K: string]: DeepReadonly<Schema> },
    T = { -readonly [K in keyof S]: Schema.ToType<S[K]> },
  >(
    components: S
  ): CoreECS<Simplify<C & T>, R>;
  withResources<T extends { readonly [K: string]: Schema & { default: any } }>(
    resources: T
  ): CoreECS<C, Simplify<R & { -readonly [K in keyof T]: Schema.ToType<T[K]> }>>;
  withResources<T extends { readonly [K: string]: Data }>(
    resources: T
  ): CoreECS<C, Simplify<R & T>>;
}

export interface CoreECSRead<
  C extends CoreComponents = CoreComponents,
  R extends CoreResources = {},
> {
  components: { readonly [K in keyof C]: Schema };
  resources: R;
  /**
   * Returns the component value for the given entity.
   * @param component the component to read.
   * @param id if not provided, uses the component own entity id as with resources.
   */
  getComponentValue<Name extends keyof C>(
    id: Entity,
    component: Name
  ): C[Name] | undefined;
  getArchetype<Components extends (keyof C)[]>(
    ...components: Components
  ): CoreArchetype<{ [K in Components[number]]: C[K] }>;
  getEntityValues(id: Entity): EntityValues<C> | undefined;
  getEntityArchetype(id: Entity): CoreArchetype;
  countEntities<T extends CoreComponents>(archetype: CoreArchetype<T>): number;
  selectEntities<T extends CoreComponents>(
    archetype: CoreArchetype<T>
  ): Entity[];
  toJSON(): ECSJSON;
}

export interface CoreECSWrite<
  C extends CoreComponents = CoreComponents,
  R extends CoreResources = {},
> {
  createEntity(): Entity;
  createEntity<T extends CoreComponents>(
    archetype: CoreArchetype<T>,
    values: Omit<T, "id">
  ): Entity;
  createBatch<T extends CoreComponents>(
    archetype: CoreArchetype<T>,
    count: number,
  ): Table<T>;
  /**
   * Sets the value of a component for the given entity.
   * @param component the component to write.
   * @param value the value of the component or undefined to delete the component.
   * @param id if not provided, uses the components own entity id as with resources.
   */
  setComponentValue<Name extends keyof C>(
    id: Entity,
    component: Name,
    value: C[Name] | undefined
  ): void;
  /**
   * Gets the tables for the given archetype in read or write mode.
   * @param exact if true, only returns the single table that exactly matches the archetype.
   */
  getTables<T extends CoreComponents>(
    archetype: CoreArchetype<T>,
    options: { mode: "read" | "write"; exact?: boolean }
  ): Table<C>[];
  updateEntity(id: Entity, values: EntityUpdateValues<C>): void;
  deleteEntity(id: Entity): void;
}

export interface CoreArchetype<C = { [K: string]: unknown }> {
  readonly components: (keyof C)[];
}

/**
 * A Table represents a collection of entities with the same exact archetype.
 */
export interface Table<C = { [K: string]: unknown }> {
  readonly rows: number;
  readonly columns: { [K in keyof C]: Column<C[K]> };
}

/**
 * A column represents an array of values for a single component.
 * Each row in the column corresponds to a single entity within the containing Table.
 * The ECS stores data as a structure of arrays.
 */
export interface Column<T> {
  get(row: number): T;
  set(row: number, value: T): void;
  /**
   * Allows unsafe direct access to the underlying native array if present.
   * Not present for constant columns.
   * For numeric tuples, the array will be of the form [a0, a1, a2, b0, b1, b2, ...]
   */
  native?: NativeArray<T extends number[] ? number : T>;
  /**
   * Is every value in this column the same?
   */
  constant: boolean;

  toJSON(length: number): Data;
  fromJSON(data: Data, length: number): void;
}
